#!/usr/bin/env python
# -*- coding: utf-8 -*-

import datetime
import errno
import select

import bitstring
import rospy
import serial
from sensor_msgs.msg import Range


class Message(object):
    """
    Enumeration of available messages
    """

    CONFIGURATION_PARAM = 0

    # Instrument settings
    SW_VERSION = 0x303332  # 032
    UNIT_SERIAL_NUM = 0x303334  # 034
    PCB_SERIAL_NUM = 0x313336  # 136
    CALIBRATION_DATE = 0x313338  # 138
    TRANSDUCER_FREQ = 0x383339  # 839

    # Communication settings
    BAUD_RATE = 0x303539  # 059
    SET_ADDRESS_485 = 0x303031  # 001
    ADDRESS_485 = 0x303032  # 002
    ADDRESS_MODE_CONF = 0x303035  # 005
    ADDRESS_MODE = 0x303036  # 006

    # Analogue settings
    SET_VOLTAGE_RANGE = 0x303934  # 094
    VOLTAGE_RANGE = 0x303935  # 095
    ANALOG_OUTPUT_TEST = 0x303936  # 096
    SET_ANALOG_RANGE_LIMIT = 0x303937  # 097
    ANALOG_RANGE_LIMIT = 0x303938  # 098

    # Sampling regime
    SINGLE_MEASURE = 0x53  # hex value of 'S'
    DATA = "$"  #
    MEASURE = 0x4D  # hex value of 'M'
    CONFIGURE = 0x23  # hex value of #
    READY_2_CONFIGURE = ">"
    SET_MEASURE_MODE = 0x303339  # 039
    OPERATING_MODE = 0x303430  # 040
    RUN = 0x303238  # 028

    # Output format
    OUTPUT_FORMAT = 0x303238  # 089
    SET_OUTPUT_FORMAT = 0x303832  # 082

    # Range settings
    SET_RANGE_UNITS = 0x303231  # 021
    RANGE_UNITS = 0x303232  # 022
    SET_ERROR_MSG = 0x313138  # 118
    ERROR_MSG = 0x313139  # 119
    MAX_RANGE = 0x383234  # 824
    MINIMUM_RANGE = 0x383431  # 841
    CHANGE_SOUND_SPEED = 0x383330  # 830
    SOUND_SPEED = 0x383331  # 831

    @classmethod
    def to_string(cls, id):
        """
        Get human-readable name corresponding to message id
        :param cls:
        :param id: message ID
        :return:
        """
        for attr, value in cls.__dict__.items():
            if value == id:
                return attr
        else:
            return None

    @classmethod
    def from_string(cls, name):
        """
        Gets message ID corresponding to human-readable name.
        :param name: Human-readable string
        :return:
        """
        if hasattr(cls, name):
            return cls.__getattribute__(name)
        else:
            return None


class Command(object):
    """
    Sonar commands
    """

    def __init__(self, id, payload=None, command=None):
        """
        Construct command object
        :param id:
        :param payload:
        """

        self.id = id

        self.payload = payload if payload else bitstring.BitStream()

        self.command = command if command else bitstring.BitStream()

    def serialize(self):
        """
        Construct string of bytes to send to sonar
        :return:
        """

        # The len must be multiple of 4 bits to convert unambiguously

        id_len = self.id.bit_length()
        while (id_len % 4) != 0:
            id_len += 1
        if self.payload:
            pay_len = self.payload.bit_length()
            while (pay_len % 4) != 0:
                pay_len += 1
        else:
            pay_len = 0
        if self.command:
            com_len = self.command.bit_length()
            while (com_len % 4) != 0:
                com_len += 1
        else:
            com_len = 0

        values = {
            "id": self.id,
            "id_len": id_len,
            "payload": self.payload,
            "payload_len": pay_len,
            "command": self.command,
            "command_len": com_len,
        }

        if self.id == Message.MEASURE or self.id == Message.SINGLE_MEASURE:
            serial_format = "uint:id_len=id, bits:payload_len=payload, bits:command_len = command, 0x0D0A"
        else:
            serial_format = "0x23, uint:id_len=id, bits:payload_len=payload, bits:command_len = command, 0x0D0A"

        message = bitstring.pack(serial_format, **values)

        rospy.logdebug("Sent command '0x%s'", message.hex)

        return message.tobytes()


class Error:
    class SonarNotFound(Exception):
        """Sonar port could not be found."""

        pass

    class DataNotSent(Exception):
        """Sonar is not sending information."""

        pass

    class PacketIncomplete(Exception):
        """Packet is incomplete."""

        pass

    class PacketCorrupted(Exception):
        """Packet is corrupt."""

        pass

    class SonarNotConfigured(Exception):
        """Sonar is not configured for scanning."""

        pass

    class TimeoutError(Exception):
        """Communication timed out."""

        pass


class Reply(object):
    """
    Parses and verifies reply packages
    """

    def __init__(self, bitstream, id=0):
        """

        :param bitstream:
        """
        self.bitstream = bitstream
        self.id = id
        self.name = Message.to_string(self.id)
        self.payload = None
        self.dataformat = "NMEA"
        self.dataunits = None

        self.parse()

    def parse(self):
        """
        Parses packet into header, message ID and payload
        :return:
        """
        try:
            if self.bitstream:
                # Parse message header
                self.bitstream.bytepos = 0

                if self.bitstream.endswith("\n"):
                    pass

                else:
                    raise Error.PacketIncomplete(
                        "Packet does not end with carriage return"
                    )

                if self.bitstream.find(
                    "0x 50 52 56 41 54", bytealigned=True
                ):  # If 'PRVAT' text in bitstream
                    self.dataformat = "NMEA"
                else:
                    self.dataformat = "TRITECH"

                if (
                    self.dataformat == "NMEA"
                    and self.id != Message.CONFIGURATION_PARAM
                ):
                    # go to first comma
                    self.bitstream.bytepos = (
                        self.bitstream.find("0x2C", bytealigned=True)[0] / 8
                        + 1
                    )
                    self.payload = self.bitstream.read("bytes:6")
                    # skip comma
                    self.bitstream.read("bytes:1")
                    self.dataunits = self.bitstream.read("bytes:1")

                elif (
                    self.dataformat == "TRITECH"
                    and self.id != Message.CONFIGURATION_PARAM
                ):
                    self.bitstream.bytepos = 0
                    self.payload = self.bitstream.read("bytes:6")
                    self.dataunits = self.bitstream.read("bytes:1")
                else:
                    self.bitstream.bytepos = 0
                    length_string = "bytes:" + str(len(self.bitstream) / 8)
                    self.payload = self.bitstream.read(length_string)

            else:
                pass

        except ValueError as e:
            raise Error.PacketCorrupted("Unexpected error", e)


class Socket(object):
    """
    Sonar connection
    """

    def __init__(self, port, baudrate):
        """

        :param port:
        :param baudrate:
        """
        self.conn = serial.Serial(timeout=2)
        self.conn.port = port
        self.conn.baudrate = baudrate

    def open(self):
        """
        Opens serial connection
        :return:
        """
        self.conn.open()

    def close(self):
        """
        Closes serial connection
        :return:
        """
        self.conn.close()

    def send(self, message, payload=None, command=None):
        """
        :param message:
        :param payload:
        :return:
        """
        cmd = Command(message, payload, command)
        rospy.logdebug("Sending %s: %s", Message.to_string(message), command)
        self.conn.write(cmd.serialize())

    def _readline(self):
        eol = b"*"
        leneol = len(eol)
        line = bytearray()
        while True:
            c = self.conn.read(1)
            if c:
                line += c
                if line[-leneol:] == eol:
                    break
            else:
                break
        return bytes(line)

    def get_reply(self, expected_reply=None, enabled=False):
        """
        Waits for and returns reply
        :return:
        """
        try:
            # Wait for the header character
            # Don't put anything in this while, because if losses packets if you do so
            if expected_reply:
                while not self.conn.read() == "$":
                    pass

            # Initialize empty packet where the received stream will be saved
            packet = bitstring.BitStream()

            if expected_reply == ">":
                message_id = Message.READY_2_CONFIGURE
                rospy.logdebug("Sonar altimeter in configuration mode")
                reply = Reply(
                    packet.append("0x{:02X}".format(ord(">"))), id=message_id
                )
                return reply

            elif expected_reply == "$":
                message_id = Message.DATA
                rospy.logdebug("Received valid packet with sensor data")
            else:
                rospy.logdebug("Received packet with configuration parameters")
                message_id = Message.CONFIGURATION_PARAM

            # Convert each caracter from received string stream in the bitstream
            current_line = []
            while enabled:
                try:
                    # Read the message sent by altimeter. It always has length 22
                    current_line.append(self.conn.read(22))
                    # Separate fields by commas
                    char = str(current_line).split(",")
                    measurement = char[1]
                    break
                except:
                    continue

        except OSError as e:
            if e.errno == errno.EINTR:
                raise KeyboardInterrupt()
            raise

        rospy.logdebug("Received: %s", measurement)
        return measurement  # reply


class VA500(object):
    """
    *VA500* class for sonar altimeter
    """

    MAX_TIMEOUT_COUNT = 5

    def __init__(
        self,
        port="/dev/ttyUSB0",
        baudrate=115200,
        frame_id="valeport_altimeter",
        min_range=0,
        max_range=10,
    ):
        """
        :param port:
        :param baudrate: Baud rate, 115200 by default (can be 9600-115200)
        """
        self.port = port
        self.baudrate = baudrate

        self.conn = None
        self.initialized = False

        # Timeout count
        self.timeout_count = 0

        self.max_range = min_range
        self.min_range = max_range

        rospy.info("Valeport altimeter node is up!")
        rospy.info("\t* port:", port)
        rospy.info("\t* baudrate:", baudrate)
        rospy.info("\t* frame_id:", frame_id)
        rospy.info("\t* max_range:", max_range)
        rospy.info("\t* min_range:", min_range)

        # Publish extracted data in personalised msg
        self.pub = rospy.Publisher("range", Range, queue_size=1)

        self.range_msg = Range()
        self.range_msg.radiation_type = 2  # Source radiation: sound
        self.range_msg.field_of_view = 0.1  # the size of the arc [rad]
        self.range_msg.header.frame_id = frame_id
        self.range_msg.min_range = self.min_range
        self.range_msg.max_range = self.max_range

    def __enter__(self):
        """
        Initializes for first use
        """
        self.open()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """
        Cleans up
        :param exc_type:
        :param exc_val:
        :param exc_tb:
        :return:
        """
        self.close()
        rospy.loginfo("Closed sonar altimeter on %s", self.port)

    def open(self):
        """
        Initializes sonar connection
        :return:
        """
        # Initialize the port
        rospy.loginfo("Initializing altimeter on %s", self.port)
        if not self.conn:
            try:
                self.conn = Socket(self.port, self.baudrate)
            except OSError as e:
                raise Error.SonarNotFound(self.port, e)
        self.initialized = True

    def close(self):
        self.conn.close()

    def scan(self):
        """
        Sends command to scan
        :return:
        """
        # send here something to verify sonar is connected?
        if not self.initialized:
            rospy.error("Sonar is not configured")
            raise Error.SonarNotConfigured(self.initialized)

        # Ask sonar to send a single measurement
        self.conn.send(Message.MEASURE)

        # Get the scan data
        try:
            data = self.get(Message.DATA, wait=1).payload
            self.range_msg.header.stamp = rospy.Time.now()
            self.range_msg.range = float(data)
            self.pub.publish(self.range_msg)
            self.timeout_count = 0
        except TimeoutError:
            self.timeout_count += 1
            rospy.logdebug("Timeout count: %d", self.timeout_count)
            if self.timeout_count >= self.MAX_TIMEOUT_COUNT:
                # Try to resend paramenters
                self.conn.send(Message.MEASURE)
                self.timeout_count = 0

    def get(self, message=None, wait=2):
        """
        Sends command and returns reply
        :param message: Message to expect
        :param wait: Seconds to wait until received
        :return:
        """
        # Verify if sonar is initialized
        if not self.initialized:
            raise Error.SonarNotConfigured

        expected_name = Message.to_string(message)
        if message:
            rospy.logdebug("Waiting for %s message", expected_name)
        else:
            rospy.logdebug("Waiting for unlabeled message")

        # Determine end time
        end = datetime.datetime.now() + datetime.timedelta(seconds=wait)

        # Wait until received if a specific message ID is requested, otherwise wait forever
        while message is None or datetime.datetime.now() < end:
            if message is None:
                try:
                    reply = self.conn.get_reply()
                    return reply
                except:
                    break
            else:
                try:
                    reply = self.conn.get_reply(message)
                except:
                    break
                # Verify reply ID if requested
            if reply.id == message:
                # rospy.logdebug("Found %s message", expected_name)
                return reply
            else:
                rospy.logwarn("Received unexpected %s message", reply.name)
        # Timeout
        rospy.logerr("Timed out before receiving message: %s", expected_name)
        raise TimeoutError()


def main():
    # Initialize node
    rospy.init_node("altimeter_node", log_level=rospy.DEBUG)

    # Add private parameters
    port = rospy.get_param("~port", "/dev/ttyUSB0")
    baudrate = rospy.get_param("~baudrate", 115200)
    rate_hz = rospy.get_param("~rate_hz", 1)
    frame_id = rospy.get_param("~frame_id", "valeport_altimeter")
    min_range_m = rospy.get_param("~min_range_m", "0")
    max_range_m = rospy.get_param("~max_range_m", "10")

    va500_altimeter = VA500(port, baudrate, frame_id, min_range_m, max_range_m)

    va500_altimeter.open()

    r = rospy.Rate(rate_hz)
    while not rospy.is_shutdown():
        va500_altimeter.scan()
        rospy.spinOnce()
        r.sleep()


if __name__ == "__main__":
    main()
